!(function(e, t) {
	"object" == typeof exports && "undefined" != typeof module
		? t(exports, require("vue"), require("firebase"))
		: "function" == typeof define && define.amd
			? define(["exports", "vue", "firebase"], t)
			: t((e.VueTransmit = {}), e.Vue, e.firebase);
})(this, function(e, t, i) {
	"use strict";
	function r(e) {
		return "function" == typeof e;
	}
	(t = t && t.hasOwnProperty("default") ? t.default : t),
		(i = i && i.hasOwnProperty("default") ? i.default : i);
	var s,
		a,
		n,
		o = 0;
	function l(e, t) {
		void 0 === t && (t = 2);
		var i = Math.pow(10, t);
		return Math.round(e * i) / i;
	}
	function u() {
		return {};
	}
	function d() {}
	function p(e) {
		return e.isFile;
	}
	function c(e) {
		return e.isDirectory;
	}
	((s = e.UploadStatuses || (e.UploadStatuses = {})).None = ""),
		(s.Added = "added"),
		(s.Queued = "queued"),
		(s.Accepted = "queued"),
		(s.Uploading = "uploading"),
		(s.Canceled = "canceled"),
		(s.Error = "error"),
		(s.Timeout = "timeout"),
		(s.Success = "success"),
		((a = e.ErrType || (e.ErrType = {}))[(a.Any = 0)] = "Any"),
		(a[(a.Timeout = 1)] = "Timeout"),
		((n = e.VTransmitEvents || (e.VTransmitEvents = {})).Initialize =
			"initialize"),
		(n.AddedFile = "added-file"),
		(n.AddedFiles = "added-files"),
		(n.RemovedFile = "removed-file"),
		(n.AcceptedFile = "accepted-file"),
		(n.RejectedFile = "rejected-file"),
		(n.AcceptComplete = "accept-complete"),
		(n.Thumbnail = "thumbnail"),
		(n.Processing = "processing"),
		(n.ProcessingMultiple = "processing-multiple"),
		(n.Canceled = "canceled"),
		(n.CanceledMultiple = "canceled-multiple"),
		(n.Sending = "sending"),
		(n.SendingMultiple = "sending-multiple"),
		(n.Timeout = "timeout"),
		(n.TimeoutMultiple = "timeout-multiple"),
		(n.UploadProgress = "upload-progress"),
		(n.TotalUploadProgress = "total-upload-progress"),
		(n.Success = "success"),
		(n.SuccessMultiple = "success-multiple"),
		(n.QueueComplete = "queue-complete"),
		(n.Complete = "complete"),
		(n.CompleteMultiple = "complete-multiple"),
		(n.Error = "error"),
		(n.ErrorMultiple = "error-multiple"),
		(n.MaxFilesReached = "max-files-reached"),
		(n.MaxFilesExceeded = "max-files-exceeded"),
		(n.Reset = "reset"),
		(n.DragOver = "drag-over"),
		(n.DragEnter = "drag-enter"),
		(n.DragLeave = "drag-leave"),
		(n.DragEnd = "drag-end"),
		(n.Drop = "drop"),
		(n.Paste = "paste");
	var h = (function() {
			function t(i) {
				(this._dataUrl = ""),
					(this.id = t.idFactory()),
					(this.status = e.UploadStatuses.None),
					(this.accepted = !1),
					(this.processing = !1),
					(this.width = 0),
					(this.height = 0),
					(this.errorMessage = ""),
					(this.thumbnailLoaded = !1),
					(this.driverData = {}),
					(this.meta = {}),
					(this.upload = {
						bytesSent: 0,
						progress: 0,
						total: 0,
						speed: { kbps: 0, mbps: 0 },
						start: 0,
						end: 0,
						time: 0,
					}),
					(this.nativeFile = i),
					(this.lastModified = i.lastModified),
					(this.lastModifiedDate = i.lastModifiedDate),
					(this.name = i.name),
					(this.size = i.size),
					(this.type = i.type),
					(this.webkitRelativePath = i.webkitRelativePath),
					(this.upload.total = i.size);
			}
			return (
				(t.prototype.handleProgress = function(e) {
					this.startProgress();
					var t,
						i,
						r = e.total || this.upload.total;
					(this.upload.progress = Math.min(100, (100 * e.loaded) / r)),
						(this.upload.bytesSent = e.loaded),
						(this.upload.total = r),
						(this.upload.time = (Date.now() - this.upload.start) / 1e3),
						(this.upload.speed.kbps = l(
							((t = this.upload.bytesSent),
							(i = this.upload.time),
							(function(e) {
								return e / 125;
							})(t) / i)
						)),
						(this.upload.speed.mbps = l(
							(function(e, t) {
								return (
									(function(e) {
										return e / 125e3;
									})(e) / t
								);
							})(this.upload.bytesSent, this.upload.time)
						)),
						100 === this.upload.progress && this.endProgress();
				}),
				(t.prototype.startProgress = function() {
					return (
						this.upload.start || (this.upload.start = Date.now()), this
					);
				}),
				(t.prototype.endProgress = function() {
					return (
						this.upload.end ||
							((this.upload.end = Date.now()),
							(this.upload.time =
								(Date.now() - this.upload.start) / 1e3)),
						this
					);
				}),
				Object.defineProperty(t.prototype, "dataUrl", {
					get: function() {
						return this.thumbnailLoaded ? this._dataUrl : "";
					},
					set: function(e) {
						Object.defineProperty(this, "_dataUrl", {
							value: e,
							enumerable: !1,
							configurable: !0,
							writable: !0,
						}),
							(this.thumbnailLoaded = !0);
					},
					enumerable: !0,
					configurable: !0,
				}),
				(t.idFactory = function() {
					return "vt_" + ++o;
				}),
				t
			);
		})(),
		m = (function() {
			function t(t) {
				(this.vtransmit = t),
					(this.Statuses = e.UploadStatuses),
					(this.props = t.$props);
			}
			return (
				(t.prototype.emit = function(e) {
					for (var t, i = [], r = 1; r < arguments.length; r++)
						i[r - 1] = arguments[r];
					(t = this.vtransmit).$emit.apply(t, [e].concat(i));
				}),
				Object.defineProperty(t.prototype, "acceptedFiles", {
					get: function() {
						return this.vtransmit.acceptedFiles;
					},
					enumerable: !0,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "rejectedFiles", {
					get: function() {
						return this.vtransmit.rejectedFiles;
					},
					enumerable: !0,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "addedFiles", {
					get: function() {
						return this.vtransmit.addedFiles;
					},
					enumerable: !0,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "queuedFiles", {
					get: function() {
						return this.vtransmit.queuedFiles;
					},
					enumerable: !0,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "uploadingFiles", {
					get: function() {
						return this.vtransmit.uploadingFiles;
					},
					enumerable: !0,
					configurable: !0,
				}),
				Object.defineProperty(t.prototype, "activeFiles", {
					get: function() {
						return this.vtransmit.activeFiles;
					},
					enumerable: !0,
					configurable: !0,
				}),
				t
			);
		})();
	function f(e, t) {
		return r(e) ? e(t) : e;
	}
	!(function(e) {
		(e[(e.Empty = 0)] = "Empty"),
			(e[(e.Indexed = 1)] = "Indexed"),
			(e[(e.Brackets = 2)] = "Brackets");
	})(e.ParamNameStyle || (e.ParamNameStyle = {}));
	var g,
		v = 0,
		y = (function() {
			function t(t, i) {
				this.uploadGroups = Object.create(null);
				var r = i.url,
					s = i.method,
					a = void 0 === s ? "post" : s,
					n = i.withCredentials,
					o = void 0 !== n && n,
					l = i.timeout,
					u = void 0 === l ? 0 : l,
					d = i.paramName,
					p = void 0 === d ? "file" : d,
					c = i.multipleParamNameStyle,
					h = void 0 === c ? e.ParamNameStyle.Empty : c,
					m = i.params,
					f = void 0 === m ? Object.create(null) : m,
					g = i.headers,
					v =
						void 0 === g
							? {
									Accept: "application/json",
									"Cache-Control": "no-cache",
									"X-Requested-With": "XMLHttpRequest",
							  }
							: g,
					y = i.responseType,
					F = void 0 === y ? "json" : y,
					T = i.responseParseFunc,
					E = i.errUploadError,
					b =
						void 0 === E
							? function(e) {
									return (
										"Error during upload: " +
										e.statusText +
										" [" +
										e.status +
										"]"
									);
							  }
							: E,
					S = i.errUploadTimeout,
					P =
						void 0 === S
							? function(e) {
									return "Error during upload: the server timed out.";
							  }
							: S,
					x = i.renameFile,
					U =
						void 0 === x
							? function(e) {
									return e;
							  }
							: x;
				if (!r)
					throw new TypeError(
						this.constructor.name +
							" requires a 'url' parameter. Supply a string or a function returning a string."
					);
				(this.context = t),
					(this.url = r),
					(this.method = a),
					(this.withCredentials = o),
					(this.timeout = u),
					(this.paramName = p),
					(this.multipleParamNameStyle = h),
					(this.params = f),
					(this.headers = v),
					(this.responseType = F),
					(this.responseParseFunc = T),
					(this.errUploadError = b),
					(this.errUploadTimeout = P),
					(this.renameFile = U);
			}
			return (
				(t.prototype.uploadFiles = function(t) {
					var i = this;
					return new Promise(function(r) {
						if (!i.url)
							return r({
								ok: !1,
								err: {
									type: e.ErrType.Any,
									message: "Missing upload URL.",
									data: i.url,
								},
							});
						var s = new XMLHttpRequest(),
							a = i.handleUploadProgress(t),
							n = v++,
							o = f(i.params, t),
							l = f(i.headers, t);
						i.uploadGroups[n] = { id: n, xhr: s, files: t };
						for (var u = 0, d = t; u < d.length; u++) {
							((b = d[u]).driverData.groupID = n), b.startProgress();
						}
						s.open(f(i.method, t), f(i.url, t), !0),
							(s.timeout = f(i.timeout, t)),
							(s.withCredentials = f(i.withCredentials, t)),
							(s.responseType = f(i.responseType, t)),
							s.addEventListener("error", function() {
								i.rmGroup(n),
									r({
										ok: !1,
										err: {
											type: e.ErrType.Any,
											message: i.errUploadError(s),
											data: s,
										},
									});
							}),
							s.upload.addEventListener("progress", a),
							s.addEventListener("timeout", function() {
								i.rmGroup(n),
									r({
										ok: !1,
										err: {
											type: e.ErrType.Timeout,
											message: i.errUploadTimeout(s),
											data: s,
										},
									});
							}),
							s.addEventListener("load", function() {
								if (
									t[0].status !== e.UploadStatuses.Canceled &&
									s.readyState === XMLHttpRequest.DONE
								) {
									var o;
									if ((i.rmGroup(n), i.responseParseFunc))
										o = i.responseParseFunc(s);
									else if (((o = s.response), !s.responseType)) {
										var l = s.getResponseHeader("content-type");
										if (l && l.indexOf("application/json") > -1)
											try {
												o = JSON.parse(s.responseText);
											} catch (t) {
												return r({
													ok: !1,
													err: {
														message:
															"Invalid JSON response from server.",
														type: e.ErrType.Any,
														data: t,
													},
												});
											}
									}
									return (
										a(),
										s.status < 200 || s.status >= 300
											? r({
													ok: !1,
													err: {
														type: e.ErrType.Any,
														message: i.errUploadError(s),
														data: s,
													},
											  })
											: r({ ok: !0, data: o })
									);
								}
							});
						for (var p = 0, c = Object.keys(l); p < c.length; p++) {
							var h = c[p];
							l[h] && s.setRequestHeader(h, l[h]);
						}
						for (
							var m = new FormData(), g = 0, y = Object.keys(o);
							g < y.length;
							g++
						) {
							var F = y[g];
							m.append(F, o[F]);
						}
						for (var T = 0, E = t; T < E.length; T++) {
							var b = E[T];
							i.context.emit(e.VTransmitEvents.Sending, b, s, m);
						}
						i.context.props.uploadMultiple &&
							i.context.emit(e.VTransmitEvents.SendingMultiple, t, s, m);
						for (var S = 0, P = t.length; S < P; S++)
							m.append(
								i.getParamName(t[S], S),
								t[S].nativeFile,
								i.renameFile(t[S].name)
							);
						s.send(m);
					});
				}),
				(t.prototype.handleUploadProgress = function(t) {
					var i = this.context.vtransmit;
					return function(r) {
						if (!r) {
							for (var s = !0, a = 0, n = t; a < n.length; a++) {
								(100 === (u = n[a]).upload.progress &&
									u.upload.bytesSent === u.upload.total) ||
									(s = !1),
									(u.upload.progress = 100),
									(u.upload.bytesSent = u.upload.total),
									u.endProgress();
							}
							if (s) return;
						}
						for (var o = 0, l = t; o < l.length; o++) {
							var u = l[o];
							r && u.handleProgress(r),
								i.$emit(
									e.VTransmitEvents.UploadProgress,
									u,
									u.upload.progress,
									u.upload.bytesSent
								);
						}
					};
				}),
				(t.prototype.getParamName = function(t, i) {
					var s;
					if (
						((s = r(this.paramName) ? this.paramName(t) : this.paramName),
						!this.context.props.uploadMultiple)
					)
						return s;
					switch (this.multipleParamNameStyle) {
						case e.ParamNameStyle.Indexed:
							s += "[" + i + "]";
							break;
						case e.ParamNameStyle.Brackets:
							s += "[]";
							break;
						case e.ParamNameStyle.Empty:
					}
					return s;
				}),
				(t.prototype.cancelUpload = function(e) {
					var t = this.uploadGroups[e.driverData.groupID];
					return t
						? (t.xhr.abort(),
						  this.rmGroup(e.driverData.groupID),
						  t.files.slice())
						: [];
				}),
				(t.prototype.rmGroup = function(e) {
					delete this.uploadGroups[e];
				}),
				t
			);
		})(),
		F = t.extend({
			render: function() {
				var e = this,
					t = e.$createElement,
					i = e._self._c || t;
				return i(
					e.tag,
					{ tag: "component" },
					[
						e.filesSlotFirst
							? e._t("files", null, null, e.fileSlotBindings)
							: e._e(),
						e._v(" "),
						i(
							"div",
							e._g(
								e._b(
									{
										staticClass: "v-transmit__upload-area",
										class: [e.isDraggingClass, e.uploadAreaClasses],
										attrs: { draggable: !e.disableDraggable },
										on: {
											click: e.handleClickUploaderAction,
											dragstart: e.handleDragStart,
											dragend: e.handleDragEnd,
											dragenter: function(t) {
												return (
													t.preventDefault(),
													t.stopPropagation(),
													e.handleDragEnter(t)
												);
											},
											dragover: function(t) {
												return (
													t.preventDefault(),
													t.stopPropagation(),
													e.handleDragOver(t)
												);
											},
											dragleave: e.handleDragLeave,
											drop: function(t) {
												return (
													t.preventDefault(),
													t.stopPropagation(),
													e.handleDrop(t)
												);
											},
										},
									},
									"div",
									e.uploadAreaAttrs,
									!1
								),
								e.uploadAreaListeners
							),
							[e._t("default")],
							2
						),
						e._v(" "),
						e.filesSlotFirst
							? e._e()
							: e._t("files", null, null, e.fileSlotBindings),
						e._v(" "),
						i("form", { ref: "uploadForm", style: e.formStyles }, [
							i("input", {
								ref: "hiddenFileInput",
								class: [e.maxFilesReachedClass],
								attrs: {
									type: "file",
									multiple: e.multiple,
									accept: e.filesToAccept,
									capture: e.capture,
								},
								on: { change: e.onFileInputChange },
							}),
						]),
					],
					2
				);
			},
			staticRenderFns: [],
			name: "VueTransmit",
			props: {
				tag: { type: String, default: "div" },
				disableDraggable: { type: Boolean, default: !1 },
				uploadAreaClasses: { type: [Array, Object, String], default: null },
				uploadAreaAttrs: { type: Object, default: u },
				uploadAreaListeners: { type: Object, default: u },
				dragClass: { type: String, default: null },
				filesSlotFirst: { type: Boolean, default: !1 },
				maxConcurrentUploads: { type: Number, default: 2 },
				uploadMultiple: { type: Boolean, default: !1 },
				maxFileSize: { type: Number, default: 256 },
				useBinarySizeBase: { type: Boolean, default: !1 },
				createImageThumbnails: { type: Boolean, default: !0 },
				maxThumbnailFileSize: { type: Number, default: 10 },
				thumbnailWidth: { type: Number, default: 120 },
				thumbnailHeight: { type: Number, default: 120 },
				maxFiles: { type: Number, default: null },
				clickable: { type: Boolean, default: !0 },
				ignoreHiddenFiles: { type: Boolean, default: !0 },
				acceptedFileTypes: {
					type: Array,
					default: function() {
						return [];
					},
				},
				autoProcessQueue: { type: Boolean, default: !0 },
				autoQueue: { type: Boolean, default: !0 },
				capture: { type: String, default: null },
				errMaxFileSizeExceeded: {
					type: Function,
					default: function(e, t, i) {
						return (
							"The file is too big (" +
							l(e, 1) +
							i +
							"). Max file size: " +
							l(t, 1) +
							i +
							"."
						);
					},
				},
				errInvalidFileType: {
					type: Function,
					default: function(e, t, i) {
						return "You can't upload files of this type: " + e;
					},
				},
				errMaxFilesExceeded: {
					type: Function,
					default: function(e) {
						return "You can not upload any more files (" + e + " max).";
					},
				},
				accept: {
					type: Function,
					default: function(e, t) {
						t();
					},
				},
				resize: {
					type: Function,
					default: function(e, t) {
						var i,
							r,
							s,
							a = e.width / e.height,
							n = t.width / t.height,
							o = {
								sx: 0,
								sy: 0,
								sWidth: e.width,
								sHeight: e.height,
								dx: 0,
								dy: 0,
								dWidth: t.width,
								dHeight: t.height,
							};
						return (
							n > a
								? ((i = e.width), (s = n), (r = e.width / s))
								: ((i = (function(e, t) {
										return t * e;
								  })(n, e.height)),
								  (r = e.height)),
							i < e.width &&
								((o.sx = (e.width - i) / 2), (o.sWidth = i)),
							r < e.height &&
								((o.sy = (e.height - r) / 2), (o.sHeight = r)),
							o
						);
					},
				},
				driverOptions: { type: Object, default: u },
				driver: { type: Function, default: y },
			},
			mounted: function() {
				var t = this;
				this.$on(
					e.VTransmitEvents.UploadProgress,
					this.updateTotalUploadProgress
				),
					this.$on(
						e.VTransmitEvents.RemovedFile,
						this.updateTotalUploadProgress
					),
					this.$on(e.VTransmitEvents.Canceled, function(i) {
						return t.$emit(e.VTransmitEvents.Complete, i);
					}),
					this.$on(e.VTransmitEvents.Complete, function(i) {
						0 === t.addedFiles.length &&
							0 === t.uploadingFiles.length &&
							0 === t.queuedFiles.length &&
							Promise.resolve().then(function() {
								return t.$emit(e.VTransmitEvents.QueueComplete, i);
							});
					}),
					window.addEventListener("paste", this.handlePaste),
					this.$emit(e.VTransmitEvents.Initialize, this);
			},
			beforeDestroy: function() {
				window.removeEventListener("paste", this.handlePaste);
			},
			data: function() {
				return {
					dragging: !1,
					processingThumbnail: !1,
					thumbnailQueue: [],
					files: [],
					defaultHeaders: {
						Accept: "application/json",
						"Cache-Control": "no-cache",
						"X-Requested-With": "XMLHttpRequest",
					},
					formStyles: {
						visibility: "hidden !important",
						position: "absolute !important",
						top: "0 !important",
						left: "0 !important",
						height: "0px !important",
						width: "0px !important",
					},
				};
			},
			computed: {
				inputEl: function() {
					var e = this.$refs.hiddenFileInput;
					return e instanceof HTMLInputElement ? e : null;
				},
				formEl: function() {
					var e = this.$refs.uploadForm;
					return e instanceof HTMLFormElement ? e : null;
				},
				fileSizeBase: function() {
					return this.useBinarySizeBase ? 1024 : 1e3;
				},
				maxFileSizeBytes: function() {
					return this.maxFileSize * this.fileSizeBase * this.fileSizeBase;
				},
				filesToAccept: function() {
					return this.acceptedFileTypes.join(",");
				},
				multiple: function() {
					return null === this.maxFiles || this.maxFiles > 1;
				},
				addedFiles: function() {
					return this.getFilesWithStatus(e.UploadStatuses.Added);
				},
				queuedFiles: function() {
					return this.getFilesWithStatus(e.UploadStatuses.Queued);
				},
				acceptedFiles: function() {
					return this.files.filter(function(e) {
						return e.accepted;
					});
				},
				rejectedFiles: function() {
					return this.files.filter(function(e) {
						return !e.accepted;
					});
				},
				uploadingFiles: function() {
					return this.getFilesWithStatus(e.UploadStatuses.Uploading);
				},
				canceledFiles: function() {
					return this.getFilesWithStatus(e.UploadStatuses.Canceled);
				},
				failedFiles: function() {
					return this.getFilesWithStatus(e.UploadStatuses.Error);
				},
				timeoutFiles: function() {
					return this.getFilesWithStatus(e.UploadStatuses.Timeout);
				},
				successfulFiles: function() {
					return this.getFilesWithStatus(e.UploadStatuses.Success);
				},
				activeFiles: function() {
					return this.getFilesWithStatus(
						e.UploadStatuses.Uploading,
						e.UploadStatuses.Queued
					);
				},
				maxFilesReached: function() {
					return (
						null != this.maxFiles &&
						this.acceptedFiles.length >= this.maxFiles
					);
				},
				maxFilesReachedClass: function() {
					return this.maxFilesReached
						? "v-transmit__max-files--reached"
						: null;
				},
				isDraggingClass: function() {
					var e;
					return (
						((e = {
							"v-transmit__upload-area--is-dragging": this.dragging,
						})[this.dragClass] = this.dragging),
						e
					);
				},
				isUploading: function() {
					return this.uploadingFiles.length > 0;
				},
				fileSlotBindings: function() {
					return {
						files: this.files,
						acceptedFiles: this.acceptedFiles,
						rejectedFiles: this.rejectedFiles,
						addedFiles: this.addedFiles,
						queuedFiles: this.queuedFiles,
						uploadingFiles: this.uploadingFiles,
						canceledFiles: this.canceledFiles,
						failedFiles: this.failedFiles,
						timeoutFiles: this.timeoutFiles,
						successfulFiles: this.successfulFiles,
						activeFiles: this.activeFiles,
						isUploading: this.isUploading,
					};
				},
				transport: function() {
					var e = this.driver;
					try {
						return new e(new m(this), this.driverOptions);
					} catch (e) {
						throw (console.error(
							"[vue-transmit] Error resolving upload driver:",
							e
						),
						e);
					}
				},
			},
			watch: {
				acceptedFiles: function(t) {
					null != this.maxFiles &&
						t.length >= this.maxFiles &&
						this.$emit(e.VTransmitEvents.MaxFilesReached, this.files);
				},
			},
			methods: {
				getFilesWithStatus: function() {
					for (var e = [], t = 0; t < arguments.length; t++)
						e[t] = arguments[t];
					return this.files.filter(function(t) {
						return e.indexOf(t.status) > -1;
					});
				},
				onFileInputChange: function() {
					var t = this.inputEl,
						i = this.formEl;
					if (null == t || null == i) throw TypeError();
					t.files &&
						(this.$emit(
							e.VTransmitEvents.AddedFiles,
							Array.from(t.files).map(this.addFile)
						),
						i.reset());
				},
				addFile: function(t) {
					var i = this,
						r = new h(t);
					return (
						(r.status = e.UploadStatuses.Added),
						this.files.push(r),
						this.$emit(e.VTransmitEvents.AddedFile, r),
						this.enqueueThumbnail(r),
						this.acceptFile(r, function(t) {
							if (t)
								return (
									(r.accepted = !1),
									i.errorProcessing([r], t),
									i.$emit(e.VTransmitEvents.RejectedFile, r),
									void i.$emit(e.VTransmitEvents.AcceptComplete, r)
								);
							(r.accepted = !0),
								i.$emit(e.VTransmitEvents.AcceptedFile, r),
								i.$emit(e.VTransmitEvents.AcceptComplete, r),
								i.autoQueue && i.enqueueFile(r);
						}),
						r
					);
				},
				acceptFile: function(t, i) {
					if (t.size > this.maxFileSizeBytes) {
						var r = this.fileSizeBase * this.fileSizeBase,
							s = t.size / r,
							a = "MB";
						return (
							this.useBinarySizeBase && (a = "MiB"),
							i(this.errMaxFileSizeExceeded(s, this.maxFileSize, a))
						);
					}
					return this.isValidFileType(t, this.acceptedFileTypes)
						? null != this.maxFiles &&
						  this.acceptedFiles.length >= this.maxFiles
							? (this.$emit(e.VTransmitEvents.MaxFilesExceeded, t),
							  i(this.errMaxFilesExceeded(this.maxFiles)))
							: void this.accept(t, i)
						: i(
								this.errInvalidFileType(
									t.type,
									this.acceptedFileTypes,
									t
								)
						  );
				},
				removeFile: function(t) {
					t.status === e.UploadStatuses.Uploading && this.cancelUpload(t);
					var i = this.files.findIndex(function(e) {
						return e.id === t.id;
					});
					i > -1 &&
						(this.$emit(
							e.VTransmitEvents.RemovedFile,
							this.files.splice(i, 1)[0]
						),
						0 === this.files.length &&
							this.$emit(e.VTransmitEvents.Reset));
				},
				removeFilesWithStatus: function() {
					for (var e = [], t = 0; t < arguments.length; t++)
						e[t] = arguments[t];
					this.getFilesWithStatus.apply(this, e).map(this.removeFile);
				},
				removeAllFiles: function(t) {
					void 0 === t && (t = !1),
						this.files
							.filter(function(i) {
								return i.status !== e.UploadStatuses.Uploading || t;
							})
							.map(this.removeFile);
				},
				triggerBrowseFiles: function() {
					this.inputEl && this.inputEl.click();
				},
				handleClickUploaderAction: function() {
					this.clickable && this.triggerBrowseFiles();
				},
				enqueueFile: function(t) {
					if (t.status !== e.UploadStatuses.Added || !0 !== t.accepted)
						throw new Error(
							"This file can't be queued because it has already been processed or was rejected."
						);
					(t.status = e.UploadStatuses.Queued),
						this.autoProcessQueue &&
							Promise.resolve().then(this.processQueue);
				},
				enqueueThumbnail: function(e) {
					!this.createImageThumbnails ||
						!e.type.match(/image.*/) ||
						e.size > 1024 * this.maxThumbnailFileSize * 1024 ||
						(this.thumbnailQueue.push(e),
						Promise.resolve().then(this.processThumbnailQueue));
				},
				processThumbnailQueue: function() {
					var e,
						t = this;
					this.processingThumbnail ||
						0 === this.thumbnailQueue.length ||
						((this.processingThumbnail = !0),
						(e = this.thumbnailQueue.shift()) &&
							this.createThumbnail(e, function() {
								(t.processingThumbnail = !1), t.processThumbnailQueue();
							}));
				},
				createThumbnail: function(t, i) {
					var r = this;
					void 0 === i && (i = d);
					var s = new FileReader();
					s.addEventListener(
						"load",
						function() {
							"image/svg+xml" === t.type &&
								((t.dataUrl = s.result),
								r.$emit(e.VTransmitEvents.Thumbnail, t, s.result),
								i()),
								r.createThumbnailFromUrl(t, s.result, i);
						},
						!1
					),
						s.readAsDataURL(t.nativeFile);
				},
				createThumbnailFromUrl: function(t, i, r) {
					var s = this,
						a = document.createElement("img");
					a.addEventListener(
						"load",
						function() {
							var i;
							(t.width = a.width), (t.height = a.height);
							var n = s.resize(t, {
									width: s.thumbnailWidth,
									height: s.thumbnailHeight,
								}),
								o = document.createElement("canvas");
							if ((i = o.getContext("2d"))) {
								(o.width = n.dWidth),
									(o.height = n.dHeight),
									i.drawImage(
										a,
										n.sx,
										n.sy,
										n.sWidth,
										n.sHeight,
										n.dx,
										n.dy,
										n.dWidth,
										n.dHeight
									);
								var l = o.toDataURL("image/png");
								return (
									(t.dataUrl = l),
									s.$emit(e.VTransmitEvents.Thumbnail, t, l),
									r ? r() : void 0
								);
							}
						},
						!1
					),
						r && a.addEventListener("error", r, !1),
						(a.src = i);
				},
				processQueue: function() {
					var e = this.uploadingFiles.length;
					if (
						!(
							e >= this.maxConcurrentUploads ||
							0 === this.queuedFiles.length
						)
					) {
						if (this.uploadMultiple)
							return this.processFiles(
								this.queuedFiles.slice(0, this.maxConcurrentUploads - e)
							);
						for (var t, i = e; i < this.maxConcurrentUploads; i++)
							(t = this.queuedFiles.shift()) && this.processFile(t);
					}
				},
				processFile: function(e) {
					this.processFiles([e]);
				},
				processFiles: function(t) {
					for (var i, r = 0, s = t; r < s.length; r++)
						((i = s[r]).processing = !0),
							(i.status = e.UploadStatuses.Uploading),
							this.$emit(e.VTransmitEvents.Processing, i);
					return (
						this.uploadMultiple &&
							this.$emit(e.VTransmitEvents.ProcessingMultiple, t),
						this.uploadFiles(t)
					);
				},
				cancelUpload: function(t) {
					if (
						((t.status !== e.UploadStatuses.Added &&
							t.status !== e.UploadStatuses.Queued) ||
							((t.status = e.UploadStatuses.Canceled),
							this.$emit(e.VTransmitEvents.Canceled, t),
							this.uploadMultiple &&
								this.$emit(e.VTransmitEvents.CanceledMultiple, [t])),
						t.status === e.UploadStatuses.Uploading)
					) {
						for (
							var i = this.transport.cancelUpload(t),
								r = void 0,
								s = 0,
								a = i;
							s < a.length;
							s++
						)
							((r = a[s]).status = e.UploadStatuses.Canceled),
								this.$emit(e.VTransmitEvents.Canceled, r);
						this.uploadMultiple &&
							this.$emit(e.VTransmitEvents.CanceledMultiple, i);
					}
					this.autoProcessQueue && this.processQueue();
				},
				uploadFile: function(e) {
					this.uploadFiles([e]);
				},
				uploadFiles: function(t) {
					var i = this;
					this.transport.uploadFiles(t).then(function(r) {
						if (r.ok) return i.uploadFinished(t, r.data);
						switch (r.err.type) {
							case e.ErrType.Any:
								i.errorProcessing(t, r.err.message, r.err.data);
								break;
							case e.ErrType.Timeout:
								i.handleTimeout(t, r.err.message, r.err.data);
								break;
							default:
								!(function(e, t) {
									throw new Error(t);
								})(r.err.type, "unmatched error case");
						}
					});
				},
				handleTimeout: function(t, i, r) {
					for (var s, a = 0, n = t; a < n.length; a++)
						((s = n[a]).status = e.UploadStatuses.Timeout),
							s.endProgress(),
							this.$emit(e.VTransmitEvents.Timeout, s, i, r);
					this.$emit(e.VTransmitEvents.TimeoutMultiple, t, i, r),
						this.autoProcessQueue && this.processQueue();
				},
				updateTotalUploadProgress: function() {
					var t = this.activeFiles.reduce(
						function(e, t) {
							return (
								(e.totalBytesSent += t.upload.bytesSent),
								(e.totalBytes += t.upload.total),
								e
							);
						},
						{ totalBytesSent: 0, totalBytes: 0, totalProgress: 100 }
					);
					this.activeFiles.length &&
						(t.totalProgress = (100 * t.totalBytesSent) / t.totalBytes),
						this.$emit(e.VTransmitEvents.TotalUploadProgress, t);
				},
				uploadFinished: function(t, i) {
					for (var r = [], s = 2; s < arguments.length; s++)
						r[s - 2] = arguments[s];
					for (var a = 0, n = t; a < n.length; a++) {
						var o = n[a];
						(o.status = e.UploadStatuses.Success),
							o.endProgress(),
							this.$emit.apply(
								this,
								[e.VTransmitEvents.Success, o, i].concat(r)
							),
							this.$emit(e.VTransmitEvents.Complete, o);
					}
					this.uploadMultiple &&
						(this.$emit.apply(
							this,
							[e.VTransmitEvents.SuccessMultiple, t, i].concat(r)
						),
						this.$emit(e.VTransmitEvents.CompleteMultiple, t)),
						this.autoProcessQueue && this.processQueue();
				},
				errorProcessing: function(t, i, r) {
					for (var s = 0, a = t; s < a.length; s++) {
						var n = a[s];
						(n.status = e.UploadStatuses.Error),
							(n.errorMessage = i),
							n.endProgress(),
							this.$emit(e.VTransmitEvents.Error, n, i, r),
							this.$emit(e.VTransmitEvents.Complete, n);
					}
					if (
						(this.uploadMultiple &&
							(this.$emit(e.VTransmitEvents.ErrorMultiple, t, i, r),
							this.$emit(e.VTransmitEvents.CompleteMultiple, t)),
						this.autoProcessQueue)
					)
						return this.processQueue();
				},
				isValidFileType: function(e, t) {
					if (!t.length) return !0;
					for (
						var i,
							r = e.type,
							s = r.slice(0, r.indexOf("/")),
							a = 0,
							n = t;
						a < n.length;
						a++
					)
						switch (((i = n[a]), !0)) {
							case "." == i.charAt(0):
								if (
									-1 !==
									e.name
										.toLowerCase()
										.indexOf(
											i.toLowerCase(),
											e.name.length - i.length
										)
								)
									return !0;
								break;
							case "/*" == i.slice(-2):
								if (s === i.slice(0, -2)) return !0;
								break;
							default:
								if (r == i) return !0;
						}
					return !1;
				},
				handleDragStart: function(e) {
					this.$emit("drag-start", e);
				},
				handleDragOver: function(t) {
					var i;
					this.dragging = !0;
					try {
						i = t.dataTransfer.effectAllowed;
					} catch (e) {}
					(t.dataTransfer.dropEffect =
						"move" === i || "linkMove" === i ? "move" : "copy"),
						this.$emit(e.VTransmitEvents.DragOver, t);
				},
				handleDragEnter: function(t) {
					(this.dragging = !0), this.$emit(e.VTransmitEvents.DragEnter, t);
				},
				handleDragLeave: function(t) {
					(this.dragging = !1), this.$emit(e.VTransmitEvents.DragLeave, t);
				},
				handleDragEnd: function(t) {
					(this.dragging = !1), this.$emit(e.VTransmitEvents.DragEnd, t);
				},
				handleDrop: function(t) {
					var i, r;
					((this.dragging = !1), t.dataTransfer) &&
						(this.$emit(e.VTransmitEvents.Drop, t),
						this.$emit(
							e.VTransmitEvents.AddedFiles,
							(i = Array.from(t.dataTransfer.files))
						),
						t.dataTransfer.items &&
						(r = Array.from(t.dataTransfer.items)) &&
						r.length &&
						(r[0].getAsFile || r[0].webkitGetAsEntry)
							? this.addFilesFromItems(r)
							: this.handleFiles(i));
				},
				handlePaste: function(t) {
					t.clipboardData || window.clipboardData;
					if (t && t.clipboardData && t.clipboardData.items) {
						this.$emit(e.VTransmitEvents.Paste, t);
						var i = Array.from(t.clipboardData.items);
						i.length && this.addFilesFromItems(i);
					}
				},
				handleFiles: function(e) {
					return e.map(this.addFile);
				},
				addFilesFromItems: function(e) {
					for (var t, i = 0, r = e; i < r.length; i++) {
						var s = r[i];
						if (s.getAsFile && "file" == s.kind) {
							var a = s.getAsFile();
							a && this.addFile(a);
						} else if (s.webkitGetAsEntry) {
							if (null == (t = s.webkitGetAsEntry())) continue;
							if (p(t)) {
								t.file(this.addFile, console.error);
								continue;
							}
							if (c(t)) {
								this.addFilesFromDirectory(t, t.name);
								continue;
							}
						}
					}
				},
				addFilesFromDirectory: function(e, t) {
					var i = this;
					e.createReader().readEntries(function(e) {
						for (var r = 0, s = e; r < s.length; r++) {
							var a = s[r];
							null != a &&
								(c(a)
									? i.addFilesFromDirectory(a, t + "/" + a.name)
									: p(a) &&
									  a.file(function(e) {
											(i.ignoreHiddenFiles &&
												"." == e.name.charAt(0)) ||
												((e.fullPath = t + "/" + e.name),
												i.addFile(e));
									  }, console.error));
						}
					}, console.error);
				},
			},
		}),
		T = (function() {
			function t(e, t) {
				(this.context = e),
					(this.options = t),
					(this.cancelTokens = Object.create(null));
			}
			return (
				(t.prototype.cancelUpload = function(t) {
					var i = this.cancelTokens[t.id];
					return i
						? (i(),
						  delete this.cancelTokens[t.id],
						  this.context.emit(e.VTransmitEvents.Canceled, t),
						  [t])
						: [];
				}),
				(t.prototype.uploadFiles = function(t) {
					var r = this;
					console.log("firebase upload", { files: t });
					for (
						var s = [],
							a = function(a, n) {
								var o = t[a];
								s.push(
									new Promise(function(s) {
										var n = r.options.storageRef(o),
											l =
												r.options.metadata && r.options.metadata(o),
											u = n.put(t[a].nativeFile, l);
										(r.cancelTokens[o.id] = function() {
											return u.cancel();
										}),
											u.on(i.storage.TaskEvent.STATE_CHANGED, {
												complete: function() {
													delete r.cancelTokens[o.id], s();
												},
												next: function(t) {
													r.context.emit(
														e.VTransmitEvents.UploadProgress,
														o,
														(t.bytesTransferred / t.totalBytes) *
															100,
														t.bytesTransferred
													);
												},
												error: console.error,
											});
									})
								);
							},
							n = 0,
							o = t.length;
						n < o;
						n++
					)
						a(n);
					return Promise.all(s).then(function() {
						return { ok: !0, data: {} };
					});
				}),
				t
			);
		})();
	!(function(e) {
		(e[(e.Empty = 0)] = "Empty"),
			(e[(e.Indexed = 1)] = "Indexed"),
			(e[(e.Brackets = 2)] = "Brackets");
	})(g || (g = {}));
	var E = 0,
		b = (function() {
			function t(e, t) {
				this.uploadGroups = Object.create(null);
				var i = t.url,
					r = t.method,
					s = void 0 === r ? "post" : r,
					a = t.withCredentials,
					n = void 0 !== a && a,
					o = t.timeout,
					l = void 0 === o ? 0 : o,
					u = t.paramName,
					d = void 0 === u ? "file" : u,
					p = t.multipleParamNameStyle,
					c = void 0 === p ? g.Empty : p,
					h = t.params,
					m = void 0 === h ? Object.create(null) : h,
					f = t.headers,
					v =
						void 0 === f
							? {
									Accept: "application/json",
									"Cache-Control": "no-cache",
									"X-Requested-With": "XMLHttpRequest",
							  }
							: f,
					y = t.responseType,
					F = void 0 === y ? "json" : y,
					T = t.responseParseFunc,
					E = t.errUploadError,
					b =
						void 0 === E
							? function(e) {
									return (
										"Error during upload: " +
										e.statusText +
										" [" +
										e.status +
										"]"
									);
							  }
							: E,
					S = t.errUploadTimeout,
					P =
						void 0 === S
							? function(e) {
									return "Error during upload: the server timed out.";
							  }
							: S,
					x = t.renameFile,
					U =
						void 0 === x
							? function(e) {
									return e;
							  }
							: x,
					w = t.http;
				if (!i)
					throw new TypeError(
						this.constructor.name +
							" requires a 'url' parameter. Supply a string or a function returning a string."
					);
				(this.context = e),
					(this.url = i),
					(this.method = s),
					(this.withCredentials = n),
					(this.timeout = l),
					(this.paramName = d),
					(this.multipleParamNameStyle = c),
					(this.params = m),
					(this.headers = v),
					(this.responseType = F),
					(this.responseParseFunc = T),
					(this.errUploadError = b),
					(this.errUploadTimeout = P),
					(this.renameFile = U),
					(this.http = w);
			}
			return (
				(t.prototype.uploadFiles = function(t) {
					var i = this;
					return new Promise(function(s) {
						if (!i.url)
							return s({
								ok: !1,
								err: {
									type: e.ErrType.Any,
									message: "Missing upload URL.",
									data: i.url,
								},
							});
						var a = new XMLHttpRequest(),
							n = E++,
							o = (function(e, t) {
								return r(e) ? e(t) : e;
							})(i.params, t);
						i.uploadGroups[n] = { id: n, xhr: a, files: t };
						for (var l = 0, u = t; l < u.length; l++) {
							((g = u[l]).driverData.groupID = n), g.startProgress();
						}
						for (
							var d = new FormData(), p = 0, c = Object.keys(o);
							p < c.length;
							p++
						) {
							var h = c[p];
							d.append(h, o[h]);
						}
						for (var m = 0, f = t; m < f.length; m++) {
							var g = f[m];
							i.context.emit(e.VTransmitEvents.Sending, g, a, d);
						}
						i.context.props.uploadMultiple &&
							i.context.emit(e.VTransmitEvents.SendingMultiple, t, a, d);
						for (var v = 0, y = t.length; v < y; v++)
							d.append(
								i.getParamName(t[v], v),
								t[v].nativeFile,
								i.renameFile(t[v].name)
							);
						i.http({
							url: i.url,
							body: d,
							timeout: i.timeout,
							withCredentials: i.withCredentials,
							onUploadProgress: function(e) {
								this.handleProgress(e);
							},
							success: function(e) {
								return s({ ok: !0, data: e });
							},
							error: function(t) {
								return s({
									ok: !1,
									err: {
										type: e.ErrType.Any,
										message: t.response.data.message,
										data: a,
									},
								});
							},
						});
					});
				}),
				(t.prototype.handleUploadProgress = function(t) {
					var i = this.context.vtransmit;
					return function(r) {
						if (!r) {
							for (var s = !0, a = 0, n = t; a < n.length; a++) {
								(100 === (u = n[a]).upload.progress &&
									u.upload.bytesSent === u.upload.total) ||
									(s = !1),
									(u.upload.progress = 100),
									(u.upload.bytesSent = u.upload.total),
									u.endProgress();
							}
							if (s) return;
						}
						for (var o = 0, l = t; o < l.length; o++) {
							var u = l[o];
							r && u.handleProgress(r),
								i.$emit(
									e.VTransmitEvents.UploadProgress,
									u,
									u.upload.progress,
									u.upload.bytesSent
								);
						}
					};
				}),
				(t.prototype.getParamName = function(e, t) {
					var i;
					if (
						((i = r(this.paramName) ? this.paramName(e) : this.paramName),
						!this.context.props.uploadMultiple)
					)
						return i;
					switch (this.multipleParamNameStyle) {
						case g.Indexed:
							i += "[" + t + "]";
							break;
						case g.Brackets:
							i += "[]";
							break;
						case g.Empty:
					}
					return i;
				}),
				(t.prototype.cancelUpload = function(e) {
					var t = this.uploadGroups[e.driverData.groupID];
					return t
						? (t.xhr.abort(),
						  this.rmGroup(e.driverData.groupID),
						  t.files.slice())
						: [];
				}),
				(t.prototype.rmGroup = function(e) {
					delete this.uploadGroups[e];
				}),
				t
			);
		})(),
		S = {
			install: function(e) {
				e.component("VueTransmit", F);
			},
			name: "vue-transmit",
		};
	(e.VueTransmit = F),
		(e.VueTransmitPlugin = S),
		(e.FirebaseDriver = T),
		(e.AxiosDriver = b),
		(e.XHRDriver = y),
		Object.defineProperty(e, "__esModule", { value: !0 });
});
//# sourceMappingURL=vue-transmit.min.js.map
