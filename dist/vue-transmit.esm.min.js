import Vue from "vue";
function is_function(e) {
	return "function" == typeof e;
}
var UploadStatuses,
	ErrType,
	VTransmitEvents,
	idCounter = 0;
function uniqueId(e) {
	return e + ++idCounter;
}
function round(e, t) {
	void 0 === t && (t = 2);
	var i = Math.pow(10, t);
	return Math.round(e * i) / i;
}
function fromBytesToKbit(e) {
	return e / 125;
}
function fromBytesToMbit(e) {
	return e / 125e3;
}
function toKbps(e, t) {
	return fromBytesToKbit(e) / t;
}
function toMbps(e, t) {
	return fromBytesToMbit(e) / t;
}
function NewObject() {
	return {};
}
function noop() {}
function scaleH(e, t) {
	return t / e;
}
function scaleW(e, t) {
	return t * e;
}
function expectNever(e, t) {
	throw new Error(t);
}
function resizeImg(e, t) {
	var i,
		r,
		s = e.width / e.height,
		a = t.width / t.height,
		n = {
			sx: 0,
			sy: 0,
			sWidth: e.width,
			sHeight: e.height,
			dx: 0,
			dy: 0,
			dWidth: t.width,
			dHeight: t.height,
		};
	return (
		a > s
			? ((i = e.width), (r = scaleH(a, e.width)))
			: ((i = scaleW(a, e.height)), (r = e.height)),
		i < e.width && ((n.sx = (e.width - i) / 2), (n.sWidth = i)),
		r < e.height && ((n.sy = (e.height - r) / 2), (n.sHeight = r)),
		n
	);
}
function webkitIsFile(e) {
	return e.isFile;
}
function webkitIsDir(e) {
	return e.isDirectory;
}
!(function(e) {
	(e.None = ""),
		(e.Added = "added"),
		(e.Queued = "queued"),
		(e.Accepted = "queued"),
		(e.Uploading = "uploading"),
		(e.Canceled = "canceled"),
		(e.Error = "error"),
		(e.Timeout = "timeout"),
		(e.Success = "success");
})(UploadStatuses || (UploadStatuses = {})),
	(function(e) {
		(e[(e.Any = 0)] = "Any"), (e[(e.Timeout = 1)] = "Timeout");
	})(ErrType || (ErrType = {})),
	(function(e) {
		(e.Initialize = "initialize"),
			(e.AddedFile = "added-file"),
			(e.AddedFiles = "added-files"),
			(e.RemovedFile = "removed-file"),
			(e.AcceptedFile = "accepted-file"),
			(e.RejectedFile = "rejected-file"),
			(e.AcceptComplete = "accept-complete"),
			(e.Thumbnail = "thumbnail"),
			(e.Processing = "processing"),
			(e.ProcessingMultiple = "processing-multiple"),
			(e.Canceled = "canceled"),
			(e.CanceledMultiple = "canceled-multiple"),
			(e.Sending = "sending"),
			(e.SendingMultiple = "sending-multiple"),
			(e.Timeout = "timeout"),
			(e.TimeoutMultiple = "timeout-multiple"),
			(e.UploadProgress = "upload-progress"),
			(e.TotalUploadProgress = "total-upload-progress"),
			(e.Success = "success"),
			(e.SuccessMultiple = "success-multiple"),
			(e.QueueComplete = "queue-complete"),
			(e.Complete = "complete"),
			(e.CompleteMultiple = "complete-multiple"),
			(e.Error = "error"),
			(e.ErrorMultiple = "error-multiple"),
			(e.MaxFilesReached = "max-files-reached"),
			(e.MaxFilesExceeded = "max-files-exceeded"),
			(e.Reset = "reset"),
			(e.DragOver = "drag-over"),
			(e.DragEnter = "drag-enter"),
			(e.DragLeave = "drag-leave"),
			(e.DragEnd = "drag-end"),
			(e.Drop = "drop"),
			(e.Paste = "paste");
	})(VTransmitEvents || (VTransmitEvents = {}));
var ParamNameStyle,
	VTransmitFile = (function() {
		function e(t) {
			(this._dataUrl = ""),
				(this.id = e.idFactory()),
				(this.status = UploadStatuses.None),
				(this.accepted = !1),
				(this.processing = !1),
				(this.width = 0),
				(this.height = 0),
				(this.errorMessage = ""),
				(this.thumbnailLoaded = !1),
				(this.driverData = {}),
				(this.meta = {}),
				(this.upload = {
					bytesSent: 0,
					progress: 0,
					total: 0,
					speed: { kbps: 0, mbps: 0 },
					start: 0,
					end: 0,
					time: 0,
				}),
				(this.nativeFile = t),
				(this.lastModified = t.lastModified),
				(this.lastModifiedDate = t.lastModifiedDate),
				(this.name = t.name),
				(this.size = t.size),
				(this.type = t.type),
				(this.webkitRelativePath = t.webkitRelativePath),
				(this.upload.total = t.size);
		}
		return (
			(e.prototype.handleProgress = function(e) {
				this.startProgress();
				var t = e.total || this.upload.total;
				(this.upload.progress = Math.min(100, (100 * e.loaded) / t)),
					(this.upload.bytesSent = e.loaded),
					(this.upload.total = t),
					(this.upload.time = (Date.now() - this.upload.start) / 1e3),
					(this.upload.speed.kbps = round(
						toKbps(this.upload.bytesSent, this.upload.time)
					)),
					(this.upload.speed.mbps = round(
						toMbps(this.upload.bytesSent, this.upload.time)
					)),
					100 === this.upload.progress && this.endProgress();
			}),
			(e.prototype.startProgress = function() {
				return this.upload.start || (this.upload.start = Date.now()), this;
			}),
			(e.prototype.endProgress = function() {
				return (
					this.upload.end ||
						((this.upload.end = Date.now()),
						(this.upload.time = (Date.now() - this.upload.start) / 1e3)),
					this
				);
			}),
			Object.defineProperty(e.prototype, "dataUrl", {
				get: function() {
					return this.thumbnailLoaded ? this._dataUrl : "";
				},
				set: function(e) {
					Object.defineProperty(this, "_dataUrl", {
						value: e,
						enumerable: !1,
						configurable: !0,
						writable: !0,
					}),
						(this.thumbnailLoaded = !0);
				},
				enumerable: !0,
				configurable: !0,
			}),
			(e.idFactory = function() {
				return uniqueId("vt_");
			}),
			e
		);
	})(),
	VTransmitUploadContext = (function() {
		function e(e) {
			(this.vtransmit = e),
				(this.Statuses = UploadStatuses),
				(this.props = e.$props);
		}
		return (
			(e.prototype.emit = function(e) {
				for (var t, i = [], r = 1; r < arguments.length; r++)
					i[r - 1] = arguments[r];
				(t = this.vtransmit).$emit.apply(t, [e].concat(i));
			}),
			Object.defineProperty(e.prototype, "acceptedFiles", {
				get: function() {
					return this.vtransmit.acceptedFiles;
				},
				enumerable: !0,
				configurable: !0,
			}),
			Object.defineProperty(e.prototype, "rejectedFiles", {
				get: function() {
					return this.vtransmit.rejectedFiles;
				},
				enumerable: !0,
				configurable: !0,
			}),
			Object.defineProperty(e.prototype, "addedFiles", {
				get: function() {
					return this.vtransmit.addedFiles;
				},
				enumerable: !0,
				configurable: !0,
			}),
			Object.defineProperty(e.prototype, "queuedFiles", {
				get: function() {
					return this.vtransmit.queuedFiles;
				},
				enumerable: !0,
				configurable: !0,
			}),
			Object.defineProperty(e.prototype, "uploadingFiles", {
				get: function() {
					return this.vtransmit.uploadingFiles;
				},
				enumerable: !0,
				configurable: !0,
			}),
			Object.defineProperty(e.prototype, "activeFiles", {
				get: function() {
					return this.vtransmit.activeFiles;
				},
				enumerable: !0,
				configurable: !0,
			}),
			e
		);
	})();
function resolveStaticOrDynamic(e, t) {
	return is_function(e) ? e(t) : e;
}
!(function(e) {
	(e[(e.Empty = 0)] = "Empty"),
		(e[(e.Indexed = 1)] = "Indexed"),
		(e[(e.Brackets = 2)] = "Brackets");
})(ParamNameStyle || (ParamNameStyle = {}));
var ParamNameStyle$1,
	group_id = 0,
	XHRDriver = (function() {
		function e(e, t) {
			this.uploadGroups = Object.create(null);
			var i = t.url,
				r = t.method,
				s = void 0 === r ? "post" : r,
				a = t.withCredentials,
				n = void 0 !== a && a,
				o = t.timeout,
				l = void 0 === o ? 0 : o,
				u = t.paramName,
				d = void 0 === u ? "file" : u,
				p = t.multipleParamNameStyle,
				c = void 0 === p ? ParamNameStyle.Empty : p,
				h = t.params,
				m = void 0 === h ? Object.create(null) : h,
				f = t.headers,
				g =
					void 0 === f
						? {
								Accept: "application/json",
								"Cache-Control": "no-cache",
								"X-Requested-With": "XMLHttpRequest",
						  }
						: f,
				v = t.responseType,
				y = void 0 === v ? "json" : v,
				F = t.responseParseFunc,
				T = t.errUploadError,
				b =
					void 0 === T
						? function(e) {
								return (
									"Error during upload: " +
									e.statusText +
									" [" +
									e.status +
									"]"
								);
						  }
						: T,
				E = t.errUploadTimeout,
				S =
					void 0 === E
						? function(e) {
								return "Error during upload: the server timed out.";
						  }
						: E,
				P = t.renameFile,
				x =
					void 0 === P
						? function(e) {
								return e;
						  }
						: P;
			if (!i)
				throw new TypeError(
					this.constructor.name +
						" requires a 'url' parameter. Supply a string or a function returning a string."
				);
			(this.context = e),
				(this.url = i),
				(this.method = s),
				(this.withCredentials = n),
				(this.timeout = l),
				(this.paramName = d),
				(this.multipleParamNameStyle = c),
				(this.params = m),
				(this.headers = g),
				(this.responseType = y),
				(this.responseParseFunc = F),
				(this.errUploadError = b),
				(this.errUploadTimeout = S),
				(this.renameFile = x);
		}
		return (
			(e.prototype.uploadFiles = function(e) {
				var t = this;
				return new Promise(function(i) {
					if (!t.url)
						return i({
							ok: !1,
							err: {
								type: ErrType.Any,
								message: "Missing upload URL.",
								data: t.url,
							},
						});
					var r = new XMLHttpRequest(),
						s = t.handleUploadProgress(e),
						a = group_id++,
						n = resolveStaticOrDynamic(t.params, e),
						o = resolveStaticOrDynamic(t.headers, e);
					t.uploadGroups[a] = { id: a, xhr: r, files: e };
					for (var l = 0, u = e; l < u.length; l++) {
						((F = u[l]).driverData.groupID = a), F.startProgress();
					}
					r.open(
						resolveStaticOrDynamic(t.method, e),
						resolveStaticOrDynamic(t.url, e),
						!0
					),
						(r.timeout = resolveStaticOrDynamic(t.timeout, e)),
						(r.withCredentials = resolveStaticOrDynamic(
							t.withCredentials,
							e
						)),
						(r.responseType = resolveStaticOrDynamic(t.responseType, e)),
						r.addEventListener("error", function() {
							t.rmGroup(a),
								i({
									ok: !1,
									err: {
										type: ErrType.Any,
										message: t.errUploadError(r),
										data: r,
									},
								});
						}),
						r.upload.addEventListener("progress", s),
						r.addEventListener("timeout", function() {
							t.rmGroup(a),
								i({
									ok: !1,
									err: {
										type: ErrType.Timeout,
										message: t.errUploadTimeout(r),
										data: r,
									},
								});
						}),
						r.addEventListener("load", function() {
							if (
								e[0].status !== UploadStatuses.Canceled &&
								r.readyState === XMLHttpRequest.DONE
							) {
								var n;
								if ((t.rmGroup(a), t.responseParseFunc))
									n = t.responseParseFunc(r);
								else if (((n = r.response), !r.responseType)) {
									var o = r.getResponseHeader("content-type");
									if (o && o.indexOf("application/json") > -1)
										try {
											n = JSON.parse(r.responseText);
										} catch (e) {
											return i({
												ok: !1,
												err: {
													message:
														"Invalid JSON response from server.",
													type: ErrType.Any,
													data: e,
												},
											});
										}
								}
								return (
									s(),
									r.status < 200 || r.status >= 300
										? i({
												ok: !1,
												err: {
													type: ErrType.Any,
													message: t.errUploadError(r),
													data: r,
												},
										  })
										: i({ ok: !0, data: n })
								);
							}
						});
					for (var d = 0, p = Object.keys(o); d < p.length; d++) {
						var c = p[d];
						o[c] && r.setRequestHeader(c, o[c]);
					}
					for (
						var h = new FormData(), m = 0, f = Object.keys(n);
						m < f.length;
						m++
					) {
						var g = f[m];
						h.append(g, n[g]);
					}
					for (var v = 0, y = e; v < y.length; v++) {
						var F = y[v];
						t.context.emit(VTransmitEvents.Sending, F, r, h);
					}
					t.context.props.uploadMultiple &&
						t.context.emit(VTransmitEvents.SendingMultiple, e, r, h);
					for (var T = 0, b = e.length; T < b; T++)
						h.append(
							t.getParamName(e[T], T),
							e[T].nativeFile,
							t.renameFile(e[T].name)
						);
					r.send(h);
				});
			}),
			(e.prototype.handleUploadProgress = function(e) {
				var t = this.context.vtransmit;
				return function(i) {
					if (!i) {
						for (var r = !0, s = 0, a = e; s < a.length; s++) {
							(100 === (l = a[s]).upload.progress &&
								l.upload.bytesSent === l.upload.total) ||
								(r = !1),
								(l.upload.progress = 100),
								(l.upload.bytesSent = l.upload.total),
								l.endProgress();
						}
						if (r) return;
					}
					for (var n = 0, o = e; n < o.length; n++) {
						var l = o[n];
						i && l.handleProgress(i),
							t.$emit(
								VTransmitEvents.UploadProgress,
								l,
								l.upload.progress,
								l.upload.bytesSent
							);
					}
				};
			}),
			(e.prototype.getParamName = function(e, t) {
				var i;
				if (
					((i = is_function(this.paramName)
						? this.paramName(e)
						: this.paramName),
					!this.context.props.uploadMultiple)
				)
					return i;
				switch (this.multipleParamNameStyle) {
					case ParamNameStyle.Indexed:
						i += "[" + t + "]";
						break;
					case ParamNameStyle.Brackets:
						i += "[]";
						break;
					case ParamNameStyle.Empty:
				}
				return i;
			}),
			(e.prototype.cancelUpload = function(e) {
				var t = this.uploadGroups[e.driverData.groupID];
				return t
					? (t.xhr.abort(),
					  this.rmGroup(e.driverData.groupID),
					  t.files.slice())
					: [];
			}),
			(e.prototype.rmGroup = function(e) {
				delete this.uploadGroups[e];
			}),
			e
		);
	})(),
	VueTransmit = Vue.extend({
		render: function() {
			var e = this,
				t = e.$createElement,
				i = e._self._c || t;
			return i(
				e.tag,
				{ tag: "component" },
				[
					e.filesSlotFirst
						? e._t("files", null, null, e.fileSlotBindings)
						: e._e(),
					e._v(" "),
					i(
						"div",
						e._g(
							e._b(
								{
									staticClass: "v-transmit__upload-area",
									class: [e.isDraggingClass, e.uploadAreaClasses],
									attrs: { draggable: !e.disableDraggable },
									on: {
										click: e.handleClickUploaderAction,
										dragstart: e.handleDragStart,
										dragend: e.handleDragEnd,
										dragenter: function(t) {
											return (
												t.preventDefault(),
												t.stopPropagation(),
												e.handleDragEnter(t)
											);
										},
										dragover: function(t) {
											return (
												t.preventDefault(),
												t.stopPropagation(),
												e.handleDragOver(t)
											);
										},
										dragleave: e.handleDragLeave,
										drop: function(t) {
											return (
												t.preventDefault(),
												t.stopPropagation(),
												e.handleDrop(t)
											);
										},
									},
								},
								"div",
								e.uploadAreaAttrs,
								!1
							),
							e.uploadAreaListeners
						),
						[e._t("default")],
						2
					),
					e._v(" "),
					e.filesSlotFirst
						? e._e()
						: e._t("files", null, null, e.fileSlotBindings),
					e._v(" "),
					i("form", { ref: "uploadForm", style: e.formStyles }, [
						i("input", {
							ref: "hiddenFileInput",
							class: [e.maxFilesReachedClass],
							attrs: {
								type: "file",
								multiple: e.multiple,
								accept: e.filesToAccept,
								capture: e.capture,
							},
							on: { change: e.onFileInputChange },
						}),
					]),
				],
				2
			);
		},
		staticRenderFns: [],
		name: "VueTransmit",
		props: {
			tag: { type: String, default: "div" },
			disableDraggable: { type: Boolean, default: !1 },
			uploadAreaClasses: { type: [Array, Object, String], default: null },
			uploadAreaAttrs: { type: Object, default: NewObject },
			uploadAreaListeners: { type: Object, default: NewObject },
			dragClass: { type: String, default: null },
			filesSlotFirst: { type: Boolean, default: !1 },
			maxConcurrentUploads: { type: Number, default: 2 },
			uploadMultiple: { type: Boolean, default: !1 },
			maxFileSize: { type: Number, default: 256 },
			useBinarySizeBase: { type: Boolean, default: !1 },
			createImageThumbnails: { type: Boolean, default: !0 },
			maxThumbnailFileSize: { type: Number, default: 10 },
			thumbnailWidth: { type: Number, default: 120 },
			thumbnailHeight: { type: Number, default: 120 },
			maxFiles: { type: Number, default: null },
			clickable: { type: Boolean, default: !0 },
			ignoreHiddenFiles: { type: Boolean, default: !0 },
			acceptedFileTypes: {
				type: Array,
				default: function() {
					return [];
				},
			},
			autoProcessQueue: { type: Boolean, default: !0 },
			autoQueue: { type: Boolean, default: !0 },
			capture: { type: String, default: null },
			errMaxFileSizeExceeded: {
				type: Function,
				default: function(e, t, i) {
					return (
						"The file is too big (" +
						round(e, 1) +
						i +
						"). Max file size: " +
						round(t, 1) +
						i +
						"."
					);
				},
			},
			errInvalidFileType: {
				type: Function,
				default: function(e, t, i) {
					return "You can't upload files of this type: " + e;
				},
			},
			errMaxFilesExceeded: {
				type: Function,
				default: function(e) {
					return "You can not upload any more files (" + e + " max).";
				},
			},
			accept: {
				type: Function,
				default: function(e, t) {
					t();
				},
			},
			resize: { type: Function, default: resizeImg },
			driverOptions: { type: Object, default: NewObject },
			driver: { type: Function, default: XHRDriver },
		},
		mounted: function() {
			var e = this;
			this.$on(
				VTransmitEvents.UploadProgress,
				this.updateTotalUploadProgress
			),
				this.$on(
					VTransmitEvents.RemovedFile,
					this.updateTotalUploadProgress
				),
				this.$on(VTransmitEvents.Canceled, function(t) {
					return e.$emit(VTransmitEvents.Complete, t);
				}),
				this.$on(VTransmitEvents.Complete, function(t) {
					0 === e.addedFiles.length &&
						0 === e.uploadingFiles.length &&
						0 === e.queuedFiles.length &&
						Promise.resolve().then(function() {
							return e.$emit(VTransmitEvents.QueueComplete, t);
						});
				}),
				window.addEventListener("paste", this.handlePaste),
				this.$emit(VTransmitEvents.Initialize, this);
		},
		beforeDestroy: function() {
			window.removeEventListener("paste", this.handlePaste);
		},
		data: function() {
			return {
				dragging: !1,
				processingThumbnail: !1,
				thumbnailQueue: [],
				files: [],
				defaultHeaders: {
					Accept: "application/json",
					"Cache-Control": "no-cache",
					"X-Requested-With": "XMLHttpRequest",
				},
				formStyles: {
					visibility: "hidden !important",
					position: "absolute !important",
					top: "0 !important",
					left: "0 !important",
					height: "0px !important",
					width: "0px !important",
				},
			};
		},
		computed: {
			inputEl: function() {
				var e = this.$refs.hiddenFileInput;
				return e instanceof HTMLInputElement ? e : null;
			},
			formEl: function() {
				var e = this.$refs.uploadForm;
				return e instanceof HTMLFormElement ? e : null;
			},
			fileSizeBase: function() {
				return this.useBinarySizeBase ? 1024 : 1e3;
			},
			maxFileSizeBytes: function() {
				return this.maxFileSize * this.fileSizeBase * this.fileSizeBase;
			},
			filesToAccept: function() {
				return this.acceptedFileTypes.join(",");
			},
			multiple: function() {
				return null === this.maxFiles || this.maxFiles > 1;
			},
			addedFiles: function() {
				return this.getFilesWithStatus(UploadStatuses.Added);
			},
			queuedFiles: function() {
				return this.getFilesWithStatus(UploadStatuses.Queued);
			},
			acceptedFiles: function() {
				return this.files.filter(function(e) {
					return e.accepted;
				});
			},
			rejectedFiles: function() {
				return this.files.filter(function(e) {
					return !e.accepted;
				});
			},
			uploadingFiles: function() {
				return this.getFilesWithStatus(UploadStatuses.Uploading);
			},
			canceledFiles: function() {
				return this.getFilesWithStatus(UploadStatuses.Canceled);
			},
			failedFiles: function() {
				return this.getFilesWithStatus(UploadStatuses.Error);
			},
			timeoutFiles: function() {
				return this.getFilesWithStatus(UploadStatuses.Timeout);
			},
			successfulFiles: function() {
				return this.getFilesWithStatus(UploadStatuses.Success);
			},
			activeFiles: function() {
				return this.getFilesWithStatus(
					UploadStatuses.Uploading,
					UploadStatuses.Queued
				);
			},
			maxFilesReached: function() {
				return (
					null != this.maxFiles &&
					this.acceptedFiles.length >= this.maxFiles
				);
			},
			maxFilesReachedClass: function() {
				return this.maxFilesReached
					? "v-transmit__max-files--reached"
					: null;
			},
			isDraggingClass: function() {
				var e;
				return (
					((e = { "v-transmit__upload-area--is-dragging": this.dragging })[
						this.dragClass
					] = this.dragging),
					e
				);
			},
			isUploading: function() {
				return this.uploadingFiles.length > 0;
			},
			fileSlotBindings: function() {
				return {
					files: this.files,
					acceptedFiles: this.acceptedFiles,
					rejectedFiles: this.rejectedFiles,
					addedFiles: this.addedFiles,
					queuedFiles: this.queuedFiles,
					uploadingFiles: this.uploadingFiles,
					canceledFiles: this.canceledFiles,
					failedFiles: this.failedFiles,
					timeoutFiles: this.timeoutFiles,
					successfulFiles: this.successfulFiles,
					activeFiles: this.activeFiles,
					isUploading: this.isUploading,
				};
			},
			transport: function() {
				var e = this.driver;
				try {
					return new e(
						new VTransmitUploadContext(this),
						this.driverOptions
					);
				} catch (e) {
					throw (console.error(
						"[vue-transmit] Error resolving upload driver:",
						e
					),
					e);
				}
			},
		},
		watch: {
			acceptedFiles: function(e) {
				null != this.maxFiles &&
					e.length >= this.maxFiles &&
					this.$emit(VTransmitEvents.MaxFilesReached, this.files);
			},
		},
		methods: {
			getFilesWithStatus: function() {
				for (var e = [], t = 0; t < arguments.length; t++)
					e[t] = arguments[t];
				return this.files.filter(function(t) {
					return e.indexOf(t.status) > -1;
				});
			},
			onFileInputChange: function() {
				var e = this.inputEl,
					t = this.formEl;
				if (null == e || null == t) throw TypeError();
				e.files &&
					(this.$emit(
						VTransmitEvents.AddedFiles,
						Array.from(e.files).map(this.addFile)
					),
					t.reset());
			},
			addFile: function(e) {
				var t = this,
					i = new VTransmitFile(e);
				return (
					(i.status = UploadStatuses.Added),
					this.files.push(i),
					this.$emit(VTransmitEvents.AddedFile, i),
					this.enqueueThumbnail(i),
					this.acceptFile(i, function(e) {
						if (e)
							return (
								(i.accepted = !1),
								t.errorProcessing([i], e),
								t.$emit(VTransmitEvents.RejectedFile, i),
								void t.$emit(VTransmitEvents.AcceptComplete, i)
							);
						(i.accepted = !0),
							t.$emit(VTransmitEvents.AcceptedFile, i),
							t.$emit(VTransmitEvents.AcceptComplete, i),
							t.autoQueue && t.enqueueFile(i);
					}),
					i
				);
			},
			acceptFile: function(e, t) {
				if (e.size > this.maxFileSizeBytes) {
					var i = this.fileSizeBase * this.fileSizeBase,
						r = e.size / i,
						s = "MB";
					return (
						this.useBinarySizeBase && (s = "MiB"),
						t(this.errMaxFileSizeExceeded(r, this.maxFileSize, s))
					);
				}
				return this.isValidFileType(e, this.acceptedFileTypes)
					? null != this.maxFiles &&
					  this.acceptedFiles.length >= this.maxFiles
						? (this.$emit(VTransmitEvents.MaxFilesExceeded, e),
						  t(this.errMaxFilesExceeded(this.maxFiles)))
						: void this.accept(e, t)
					: t(this.errInvalidFileType(e.type, this.acceptedFileTypes, e));
			},
			removeFile: function(e) {
				e.status === UploadStatuses.Uploading && this.cancelUpload(e);
				var t = this.files.findIndex(function(t) {
					return t.id === e.id;
				});
				t > -1 &&
					(this.$emit(
						VTransmitEvents.RemovedFile,
						this.files.splice(t, 1)[0]
					),
					0 === this.files.length && this.$emit(VTransmitEvents.Reset));
			},
			removeFilesWithStatus: function() {
				for (var e = [], t = 0; t < arguments.length; t++)
					e[t] = arguments[t];
				this.getFilesWithStatus.apply(this, e).map(this.removeFile);
			},
			removeAllFiles: function(e) {
				void 0 === e && (e = !1),
					this.files
						.filter(function(t) {
							return t.status !== UploadStatuses.Uploading || e;
						})
						.map(this.removeFile);
			},
			triggerBrowseFiles: function() {
				this.inputEl && this.inputEl.click();
			},
			handleClickUploaderAction: function() {
				this.clickable && this.triggerBrowseFiles();
			},
			enqueueFile: function(e) {
				if (e.status !== UploadStatuses.Added || !0 !== e.accepted)
					throw new Error(
						"This file can't be queued because it has already been processed or was rejected."
					);
				(e.status = UploadStatuses.Queued),
					this.autoProcessQueue &&
						Promise.resolve().then(this.processQueue);
			},
			enqueueThumbnail: function(e) {
				!this.createImageThumbnails ||
					!e.type.match(/image.*/) ||
					e.size > 1024 * this.maxThumbnailFileSize * 1024 ||
					(this.thumbnailQueue.push(e),
					Promise.resolve().then(this.processThumbnailQueue));
			},
			processThumbnailQueue: function() {
				var e,
					t = this;
				this.processingThumbnail ||
					0 === this.thumbnailQueue.length ||
					((this.processingThumbnail = !0),
					(e = this.thumbnailQueue.shift()) &&
						this.createThumbnail(e, function() {
							(t.processingThumbnail = !1), t.processThumbnailQueue();
						}));
			},
			createThumbnail: function(e, t) {
				var i = this;
				void 0 === t && (t = noop);
				var r = new FileReader();
				r.addEventListener(
					"load",
					function() {
						"image/svg+xml" === e.type &&
							((e.dataUrl = r.result),
							i.$emit(VTransmitEvents.Thumbnail, e, r.result),
							t()),
							i.createThumbnailFromUrl(e, r.result, t);
					},
					!1
				),
					r.readAsDataURL(e.nativeFile);
			},
			createThumbnailFromUrl: function(e, t, i) {
				var r = this,
					s = document.createElement("img");
				s.addEventListener(
					"load",
					function() {
						var t;
						(e.width = s.width), (e.height = s.height);
						var a = r.resize(e, {
								width: r.thumbnailWidth,
								height: r.thumbnailHeight,
							}),
							n = document.createElement("canvas");
						if ((t = n.getContext("2d"))) {
							(n.width = a.dWidth),
								(n.height = a.dHeight),
								t.drawImage(
									s,
									a.sx,
									a.sy,
									a.sWidth,
									a.sHeight,
									a.dx,
									a.dy,
									a.dWidth,
									a.dHeight
								);
							var o = n.toDataURL("image/png");
							return (
								(e.dataUrl = o),
								r.$emit(VTransmitEvents.Thumbnail, e, o),
								i ? i() : void 0
							);
						}
					},
					!1
				),
					i && s.addEventListener("error", i, !1),
					(s.src = t);
			},
			processQueue: function() {
				var e = this.uploadingFiles.length;
				if (
					!(
						e >= this.maxConcurrentUploads ||
						0 === this.queuedFiles.length
					)
				) {
					if (this.uploadMultiple)
						return this.processFiles(
							this.queuedFiles.slice(0, this.maxConcurrentUploads - e)
						);
					for (var t, i = e; i < this.maxConcurrentUploads; i++)
						(t = this.queuedFiles.shift()) && this.processFile(t);
				}
			},
			processFile: function(e) {
				this.processFiles([e]);
			},
			processFiles: function(e) {
				for (var t, i = 0, r = e; i < r.length; i++)
					((t = r[i]).processing = !0),
						(t.status = UploadStatuses.Uploading),
						this.$emit(VTransmitEvents.Processing, t);
				return (
					this.uploadMultiple &&
						this.$emit(VTransmitEvents.ProcessingMultiple, e),
					this.uploadFiles(e)
				);
			},
			cancelUpload: function(e) {
				if (
					((e.status !== UploadStatuses.Added &&
						e.status !== UploadStatuses.Queued) ||
						((e.status = UploadStatuses.Canceled),
						this.$emit(VTransmitEvents.Canceled, e),
						this.uploadMultiple &&
							this.$emit(VTransmitEvents.CanceledMultiple, [e])),
					e.status === UploadStatuses.Uploading)
				) {
					for (
						var t = this.transport.cancelUpload(e),
							i = void 0,
							r = 0,
							s = t;
						r < s.length;
						r++
					)
						((i = s[r]).status = UploadStatuses.Canceled),
							this.$emit(VTransmitEvents.Canceled, i);
					this.uploadMultiple &&
						this.$emit(VTransmitEvents.CanceledMultiple, t);
				}
				this.autoProcessQueue && this.processQueue();
			},
			uploadFile: function(e) {
				this.uploadFiles([e]);
			},
			uploadFiles: function(e) {
				var t = this;
				this.transport.uploadFiles(e).then(function(i) {
					if (i.ok) return t.uploadFinished(e, i.data);
					switch (i.err.type) {
						case ErrType.Any:
							t.errorProcessing(e, i.err.message, i.err.data);
							break;
						case ErrType.Timeout:
							t.handleTimeout(e, i.err.message, i.err.data);
							break;
						default:
							expectNever(i.err.type, "unmatched error case");
					}
				});
			},
			handleTimeout: function(e, t, i) {
				for (var r, s = 0, a = e; s < a.length; s++)
					((r = a[s]).status = UploadStatuses.Timeout),
						r.endProgress(),
						this.$emit(VTransmitEvents.Timeout, r, t, i);
				this.$emit(VTransmitEvents.TimeoutMultiple, e, t, i),
					this.autoProcessQueue && this.processQueue();
			},
			updateTotalUploadProgress: function() {
				var e = this.activeFiles.reduce(
					function(e, t) {
						return (
							(e.totalBytesSent += t.upload.bytesSent),
							(e.totalBytes += t.upload.total),
							e
						);
					},
					{ totalBytesSent: 0, totalBytes: 0, totalProgress: 100 }
				);
				this.activeFiles.length &&
					(e.totalProgress = (100 * e.totalBytesSent) / e.totalBytes),
					this.$emit(VTransmitEvents.TotalUploadProgress, e);
			},
			uploadFinished: function(e, t) {
				for (var i = [], r = 2; r < arguments.length; r++)
					i[r - 2] = arguments[r];
				for (var s = 0, a = e; s < a.length; s++) {
					var n = a[s];
					(n.status = UploadStatuses.Success),
						n.endProgress(),
						this.$emit.apply(
							this,
							[VTransmitEvents.Success, n, t].concat(i)
						),
						this.$emit(VTransmitEvents.Complete, n);
				}
				this.uploadMultiple &&
					(this.$emit.apply(
						this,
						[VTransmitEvents.SuccessMultiple, e, t].concat(i)
					),
					this.$emit(VTransmitEvents.CompleteMultiple, e)),
					this.autoProcessQueue && this.processQueue();
			},
			errorProcessing: function(e, t, i) {
				for (var r = 0, s = e; r < s.length; r++) {
					var a = s[r];
					(a.status = UploadStatuses.Error),
						(a.errorMessage = t),
						a.endProgress(),
						this.$emit(VTransmitEvents.Error, a, t, i),
						this.$emit(VTransmitEvents.Complete, a);
				}
				if (
					(this.uploadMultiple &&
						(this.$emit(VTransmitEvents.ErrorMultiple, e, t, i),
						this.$emit(VTransmitEvents.CompleteMultiple, e)),
					this.autoProcessQueue)
				)
					return this.processQueue();
			},
			isValidFileType: function(e, t) {
				if (!t.length) return !0;
				for (
					var i, r = e.type, s = r.slice(0, r.indexOf("/")), a = 0, n = t;
					a < n.length;
					a++
				)
					switch (((i = n[a]), !0)) {
						case "." == i.charAt(0):
							if (
								-1 !==
								e.name
									.toLowerCase()
									.indexOf(i.toLowerCase(), e.name.length - i.length)
							)
								return !0;
							break;
						case "/*" == i.slice(-2):
							if (s === i.slice(0, -2)) return !0;
							break;
						default:
							if (r == i) return !0;
					}
				return !1;
			},
			handleDragStart: function(e) {
				this.$emit("drag-start", e);
			},
			handleDragOver: function(e) {
				var t;
				this.dragging = !0;
				try {
					t = e.dataTransfer.effectAllowed;
				} catch (e) {}
				(e.dataTransfer.dropEffect =
					"move" === t || "linkMove" === t ? "move" : "copy"),
					this.$emit(VTransmitEvents.DragOver, e);
			},
			handleDragEnter: function(e) {
				(this.dragging = !0), this.$emit(VTransmitEvents.DragEnter, e);
			},
			handleDragLeave: function(e) {
				(this.dragging = !1), this.$emit(VTransmitEvents.DragLeave, e);
			},
			handleDragEnd: function(e) {
				(this.dragging = !1), this.$emit(VTransmitEvents.DragEnd, e);
			},
			handleDrop: function(e) {
				var t, i;
				((this.dragging = !1), e.dataTransfer) &&
					(this.$emit(VTransmitEvents.Drop, e),
					this.$emit(
						VTransmitEvents.AddedFiles,
						(t = Array.from(e.dataTransfer.files))
					),
					e.dataTransfer.items &&
					(i = Array.from(e.dataTransfer.items)) &&
					i.length &&
					(i[0].getAsFile || i[0].webkitGetAsEntry)
						? this.addFilesFromItems(i)
						: this.handleFiles(t));
			},
			handlePaste: function(e) {
				e.clipboardData || window.clipboardData;
				if (e && e.clipboardData && e.clipboardData.items) {
					this.$emit(VTransmitEvents.Paste, e);
					var t = Array.from(e.clipboardData.items);
					t.length && this.addFilesFromItems(t);
				}
			},
			handleFiles: function(e) {
				return e.map(this.addFile);
			},
			addFilesFromItems: function(e) {
				for (var t, i = 0, r = e; i < r.length; i++) {
					var s = r[i];
					if (s.getAsFile && "file" == s.kind) {
						var a = s.getAsFile();
						a && this.addFile(a);
					} else if (s.webkitGetAsEntry) {
						if (null == (t = s.webkitGetAsEntry())) continue;
						if (webkitIsFile(t)) {
							t.file(this.addFile, console.error);
							continue;
						}
						if (webkitIsDir(t)) {
							this.addFilesFromDirectory(t, t.name);
							continue;
						}
					}
				}
			},
			addFilesFromDirectory: function(e, t) {
				var i = this;
				e.createReader().readEntries(function(e) {
					for (var r = 0, s = e; r < s.length; r++) {
						var a = s[r];
						null != a &&
							(webkitIsDir(a)
								? i.addFilesFromDirectory(a, t + "/" + a.name)
								: webkitIsFile(a) &&
								  a.file(function(e) {
										(i.ignoreHiddenFiles &&
											"." == e.name.charAt(0)) ||
											((e.fullPath = t + "/" + e.name),
											i.addFile(e));
								  }, console.error));
					}
				}, console.error);
			},
		},
	});
function resolveStaticOrDynamic$1(e, t) {
	return is_function(e) ? e(t) : e;
}
!(function(e) {
	(e[(e.Empty = 0)] = "Empty"),
		(e[(e.Indexed = 1)] = "Indexed"),
		(e[(e.Brackets = 2)] = "Brackets");
})(ParamNameStyle$1 || (ParamNameStyle$1 = {}));
var group_id$1 = 0,
	AxiosDriver = (function() {
		function e(e, t) {
			this.uploadGroups = Object.create(null);
			var i = t.url,
				r = t.method,
				s = void 0 === r ? "post" : r,
				a = t.withCredentials,
				n = void 0 !== a && a,
				o = t.timeout,
				l = void 0 === o ? 0 : o,
				u = t.paramName,
				d = void 0 === u ? "file" : u,
				p = t.multipleParamNameStyle,
				c = void 0 === p ? ParamNameStyle$1.Empty : p,
				h = t.params,
				m = void 0 === h ? Object.create(null) : h,
				f = t.headers,
				g =
					void 0 === f
						? {
								Accept: "application/json",
								"Cache-Control": "no-cache",
								"X-Requested-With": "XMLHttpRequest",
						  }
						: f,
				v = t.responseType,
				y = void 0 === v ? "json" : v,
				F = t.responseParseFunc,
				T = t.errUploadError,
				b =
					void 0 === T
						? function(e) {
								return (
									"Error during upload: " +
									e.statusText +
									" [" +
									e.status +
									"]"
								);
						  }
						: T,
				E = t.errUploadTimeout,
				S =
					void 0 === E
						? function(e) {
								return "Error during upload: the server timed out.";
						  }
						: E,
				P = t.renameFile,
				x =
					void 0 === P
						? function(e) {
								return e;
						  }
						: P,
				U = t.http;
			if (!i)
				throw new TypeError(
					this.constructor.name +
						" requires a 'url' parameter. Supply a string or a function returning a string."
				);
			(this.context = e),
				(this.url = i),
				(this.method = s),
				(this.withCredentials = n),
				(this.timeout = l),
				(this.paramName = d),
				(this.multipleParamNameStyle = c),
				(this.params = m),
				(this.headers = g),
				(this.responseType = y),
				(this.responseParseFunc = F),
				(this.errUploadError = b),
				(this.errUploadTimeout = S),
				(this.renameFile = x),
				(this.http = U);
		}
		return (
			(e.prototype.uploadFiles = function(e) {
				var t = this;
				return new Promise(function(i) {
					if (!t.url)
						return i({
							ok: !1,
							err: {
								type: ErrType.Any,
								message: "Missing upload URL.",
								data: t.url,
							},
						});
					var r = new XMLHttpRequest(),
						s = group_id$1++,
						a = resolveStaticOrDynamic$1(t.params, e);
					t.uploadGroups[s] = { id: s, xhr: r, files: e };
					for (var n = 0, o = e; n < o.length; n++) {
						((m = o[n]).driverData.groupID = s), m.startProgress();
					}
					for (
						var l = new FormData(), u = 0, d = Object.keys(a);
						u < d.length;
						u++
					) {
						var p = d[u];
						l.append(p, a[p]);
					}
					for (var c = 0, h = e; c < h.length; c++) {
						var m = h[c];
						t.context.emit(VTransmitEvents.Sending, m, r, l);
					}
					t.context.props.uploadMultiple &&
						t.context.emit(VTransmitEvents.SendingMultiple, e, r, l);
					for (var f = 0, g = e.length; f < g; f++)
						l.append(
							t.getParamName(e[f], f),
							e[f].nativeFile,
							t.renameFile(e[f].name)
						);
					t.http({
						url: t.url,
						body: l,
						timeout: t.timeout,
						withCredentials: t.withCredentials,
						onUploadProgress: function(e) {
							this.handleProgress(e);
						},
						success: function(e) {
							return i({ ok: !0, data: e });
						},
						error: function(e) {
							return i({
								ok: !1,
								err: {
									type: ErrType.Any,
									message: e.response.data.message,
									data: r,
								},
							});
						},
					});
				});
			}),
			(e.prototype.handleUploadProgress = function(e) {
				var t = this.context.vtransmit;
				return function(i) {
					if (!i) {
						for (var r = !0, s = 0, a = e; s < a.length; s++) {
							(100 === (l = a[s]).upload.progress &&
								l.upload.bytesSent === l.upload.total) ||
								(r = !1),
								(l.upload.progress = 100),
								(l.upload.bytesSent = l.upload.total),
								l.endProgress();
						}
						if (r) return;
					}
					for (var n = 0, o = e; n < o.length; n++) {
						var l = o[n];
						i && l.handleProgress(i),
							t.$emit(
								VTransmitEvents.UploadProgress,
								l,
								l.upload.progress,
								l.upload.bytesSent
							);
					}
				};
			}),
			(e.prototype.getParamName = function(e, t) {
				var i;
				if (
					((i = is_function(this.paramName)
						? this.paramName(e)
						: this.paramName),
					!this.context.props.uploadMultiple)
				)
					return i;
				switch (this.multipleParamNameStyle) {
					case ParamNameStyle$1.Indexed:
						i += "[" + t + "]";
						break;
					case ParamNameStyle$1.Brackets:
						i += "[]";
						break;
					case ParamNameStyle$1.Empty:
				}
				return i;
			}),
			(e.prototype.cancelUpload = function(e) {
				var t = this.uploadGroups[e.driverData.groupID];
				return t
					? (t.xhr.abort(),
					  this.rmGroup(e.driverData.groupID),
					  t.files.slice())
					: [];
			}),
			(e.prototype.rmGroup = function(e) {
				delete this.uploadGroups[e];
			}),
			e
		);
	})(),
	VueTransmitPlugin = {
		install: function(e) {
			e.component("VueTransmit", VueTransmit);
		},
		name: "vue-transmit",
	};
export default VueTransmitPlugin;
export {
	VueTransmitPlugin,
	VueTransmit,
	XHRDriver,
	ParamNameStyle,
	AxiosDriver,
	ErrType,
	UploadStatuses,
	VTransmitEvents,
};
//# sourceMappingURL=vue-transmit.esm.min.js.map
